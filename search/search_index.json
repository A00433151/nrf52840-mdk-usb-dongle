{
    "docs": [
        {
            "location": "/", 
            "text": "nRF52840 Micro Dev Kit USB Dongle \nA small and low-cost nRF52840 Micro Development Kit in USB Dongle Form Factor\n\n\nDescription\n\n\nThe nRF52840 Micro Dev Kit USB Dongle is a small and low-cost development platform enabled by the nRF52840 multiprotocol SoC in a convenient USB dongle form factor.\n\n\nThe nRF52840 Micro Dev Kit USB Dongle features a programmable user button, RGB LED, up to 12 GPIOs and 2.4G Chip antenna on board.\n\n\nThe USB Dongle can be used as a low-cost Bluetooth5/Tread/802.15.4/ANT/2.4GHz multiprotocol node or development board. Alternatively the USB Dongle can be used as a Network Co-Processor(NCP) with a simple connection to a PC or other USB enabled device.\n\n\n\n\nHardware Features\n\n\n\n\nNordic nRF52840 System-on-Chip\n\n\nARM\u00ae Cortex\u00ae-M4F processor optimized for ultra-low power operation\n\n\nCombining \nBluetooth 5\n, \nBluetooth Mesh\n, \nThread\n, \nIEEE 802.15.4\n, \nANT\n and \n2.4GHz proprietary\n\n\nOn-chip NFC-A tag\n\n\nOn-chip USB 2.0 (Full speed) controller\n\n\nARM TrustZone\u00ae Cryptocell 310 security subsystem\n\n\n1 MB FLASH and 256 kB RAM\n\n\n\n\n\n\nUp to 12 GPIOs available via headers\n\n\nUser programmable Button and RGB LED\n\n\nOn-board 2.4G chip antenna \n\n\n3.3V regulator with 1A peak current output\n\n\nVBUS \n VIN Power-Path Management\n\n\nConvenient USB dongle form factor\n\n\nBreadboard-friendly with dual 10-Pin headers\n\n\nMeasures 1.65\" x 0.7\" x 0.16\" (42mm x 18mm x 4mm) without headers soldered in\n\n\n\n\nPinout Diagram\n\n\n\n\nSoftware Resource\n\n\nThe nRF52840 Micro Dev Kit USB Dongle can be used to play with : \nnRF5 SDK\n, \nOpenThread\n, \nWeb Bluetooth\n, \niBeacon\n, \nEddystone\n, and more.\n\n\n\n\n\n\n\n\nSoftware\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nnRF5 SDK\n\n\nOffical Software Development Kit for nRF51 and nRF52 Series\n\n\n\n\n\n\nOpenThread Border Router\n\n\nAn open source border router, designed to work with OpenThread\n\n\n\n\n\n\nThread Network Sniffer\n\n\nHelp you to efficiently analyze Thread network traffic\n\n\n\n\n\n\nWeb Bluetooth\n\n\nBluetooth support for the Web\n\n\n\n\n\n\niBeacon\n\n\nA Bluetooth low energy advertising message format designed by Apple\n\n\n\n\n\n\nEddystone\n\n\nA protocol specification that defines a Bluetooth low energy message format for proximity beacon messages\n\n\n\n\n\n\nCircuitPython\n\n\nA Python language for microcontrollers designed to simplify experimentation and learning\n\n\n\n\n\n\nTinyGo\n\n\nGo compiler for small devices, based on LLVM\n\n\n\n\n\n\nRust for nrf52840-mdk\n\n\nRust support for the nrf52840-mdk development board\n\n\n\n\n\n\n\n\nHardware Resource\n\n\n\n\n\n\n\n\nReleases\n\n\nDesign Files\n\n\n\n\n\n\n\n\n\n\nV1.0\n\n\nnRF52840 Micro Dev Kit USB Dongle V1.0 Pinout Diagram\nnRF52840 Micro Dev Kit USB Dongle V1.0 Schematic\nnRF52840 Micro Dev Kit USB Dongle V1.0 Board File\nnRF52840 Micro Dev Kit USB Dongle V1.0 3D STEP\n\n\n\n\n\n\n\n\nCreate an Issue\n\n\nInterested in contributing to this project? Want to report a bug? Feel free to click here:\n\n\n Create an Issue", 
            "title": "Introduction"
        }, 
        {
            "location": "/#nrf52840-micro-dev-kit-usb-dongle-a-small-and-low-cost-nrf52840-micro-development-kit-in-usb-dongle-form-factor", 
            "text": "", 
            "title": "nRF52840 Micro Dev Kit USB Dongle A small and low-cost nRF52840 Micro Development Kit in USB Dongle Form Factor"
        }, 
        {
            "location": "/#description", 
            "text": "The nRF52840 Micro Dev Kit USB Dongle is a small and low-cost development platform enabled by the nRF52840 multiprotocol SoC in a convenient USB dongle form factor.  The nRF52840 Micro Dev Kit USB Dongle features a programmable user button, RGB LED, up to 12 GPIOs and 2.4G Chip antenna on board.  The USB Dongle can be used as a low-cost Bluetooth5/Tread/802.15.4/ANT/2.4GHz multiprotocol node or development board. Alternatively the USB Dongle can be used as a Network Co-Processor(NCP) with a simple connection to a PC or other USB enabled device.", 
            "title": "Description"
        }, 
        {
            "location": "/#hardware-features", 
            "text": "Nordic nRF52840 System-on-Chip  ARM\u00ae Cortex\u00ae-M4F processor optimized for ultra-low power operation  Combining  Bluetooth 5 ,  Bluetooth Mesh ,  Thread ,  IEEE 802.15.4 ,  ANT  and  2.4GHz proprietary  On-chip NFC-A tag  On-chip USB 2.0 (Full speed) controller  ARM TrustZone\u00ae Cryptocell 310 security subsystem  1 MB FLASH and 256 kB RAM    Up to 12 GPIOs available via headers  User programmable Button and RGB LED  On-board 2.4G chip antenna   3.3V regulator with 1A peak current output  VBUS   VIN Power-Path Management  Convenient USB dongle form factor  Breadboard-friendly with dual 10-Pin headers  Measures 1.65\" x 0.7\" x 0.16\" (42mm x 18mm x 4mm) without headers soldered in", 
            "title": "Hardware Features"
        }, 
        {
            "location": "/#pinout-diagram", 
            "text": "", 
            "title": "Pinout Diagram"
        }, 
        {
            "location": "/#software-resource", 
            "text": "The nRF52840 Micro Dev Kit USB Dongle can be used to play with :  nRF5 SDK ,  OpenThread ,  Web Bluetooth ,  iBeacon ,  Eddystone , and more.     Software  Brief Description      nRF5 SDK  Offical Software Development Kit for nRF51 and nRF52 Series    OpenThread Border Router  An open source border router, designed to work with OpenThread    Thread Network Sniffer  Help you to efficiently analyze Thread network traffic    Web Bluetooth  Bluetooth support for the Web    iBeacon  A Bluetooth low energy advertising message format designed by Apple    Eddystone  A protocol specification that defines a Bluetooth low energy message format for proximity beacon messages    CircuitPython  A Python language for microcontrollers designed to simplify experimentation and learning    TinyGo  Go compiler for small devices, based on LLVM    Rust for nrf52840-mdk  Rust support for the nrf52840-mdk development board", 
            "title": "Software Resource"
        }, 
        {
            "location": "/#hardware-resource", 
            "text": "Releases  Design Files      V1.0  nRF52840 Micro Dev Kit USB Dongle V1.0 Pinout Diagram nRF52840 Micro Dev Kit USB Dongle V1.0 Schematic nRF52840 Micro Dev Kit USB Dongle V1.0 Board File nRF52840 Micro Dev Kit USB Dongle V1.0 3D STEP", 
            "title": "Hardware Resource"
        }, 
        {
            "location": "/#create-an-issue", 
            "text": "Interested in contributing to this project? Want to report a bug? Feel free to click here:   Create an Issue", 
            "title": "Create an Issue"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started with nRF52840 Micro Dev Kit USB Dongle\n\n\nCongratulations on getting the nRF52840 Micro Dev Kit USB Dongle!\n\n\nThis guide details how to get started with the nRF52840 Micro Dev Kit USB Dongle development, and what to expect when you do so.\n\n\nWhen you get a new dongle, it has been preprogrammed with the OpenThread NCP image. So you can easily set up a Thread NCP Joiner, which can be securely authenticated and commissioned onto a Thread network.\n\n\nWhat you'll need\n\n\n\n\nnRF52840 Micro Dev Kit USB Dongle\n\n\nPC running a Linux based operating system or MacOS\n\n\nwpantund\n\n\n\n\nInstalling wpantund\n\n\nwpantund\n is a user-space network interface driver/daemon that provides a native IPv6 network interface to a low-power wireless Network Co-Processor (NCP). It was written and developed by Nest Labs to make supporting Thread connectivity on Unix-like operating systems more straightforward.\n\n\nwpantund\n is designed to marshall all access to the NCP, ensuring that it always remains in a consistent and well-defined state.\n\n\nFollow the \nwpantund Installation Guide\n to install wpantund on Ubuntu or macOS.\n\n\nConnecting the USB Dongle\n\n\nConnect the nRF52840 Micro Dev Kit USB Dongle to your host as shown below: \n\n\n\n\nThe USB Dongle will be recognized as an nRF52840 OpenThread Device like this:\n\n\n\n\nConfigure wpantund\n\n\nIn the NCP design, use \nwpantund\n to communicate with and manage the Thread device.\n\n\nIn a terminal window, start \nwpantund\n on the serial port with the NCP, creating the interface \nutun7\n and enabling info logs:\n\n\n$ sudo /usr/local/sbin/wpantund -o Config:NCP:SocketPath /dev/cu.usbmodem14112  \n\\\n\n        -o Config:TUN:InterfaceName utun7 \n\\\n\n        -o Daemon:SyslogMask \n -info\n\n\n\n\n\n\n\nTip\n\n\nTo configure wpantund without using command line parameters, modify the \n/etc/wpantund.conf\n file.\n\n\n\n\nIf the NCP is successfully running OpenThread, the output should be similar to the below:\n\n\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: Starting wpantund \n0\n.08.00d \n(\nJun  \n9\n \n2018\n \n00\n:31:51\n)\n . . .\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n:  \nSOURCE_VERSION\n \n=\n \n0\n.07.01-217-g86d29d6\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n:  \nBUILD_VERSION\n \n=\n \n0\n.07.01-217-g86d29d6\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: Configuration file \n/etc/wpantund.conf\n read.\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: Ready. Using DBUS bus \n:1.0\n\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: Running as root without dropping privileges!\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: \n[\n-NCP-\n]\n: NCP was reset \n(\nSTATUS_RESET_POWER_ON, \n112\n)\n\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nError\n: Unexpected reset during NCP initialization.\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nError\n: Resetting and trying again... \n(\nretry \n1\n)\n\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: \n[\n-NCP-\n]\n: NCP was reset \n(\nSTATUS_RESET_POWER_ON, \n112\n)\n\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: State change: \nuninitialized\n -\n \noffline\n\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: NCP is running \nOPENTHREAD/20170716-00745-g79e35c57; NRF52840; Jul 15 2018 09:52:08\n\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: Driver is running \n0.08.00d (0.07.01-217-g86d29d6; Jun  9 2018 00:31:51)\n\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: Network is not joinable\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: Resetting interface\n(\ns\n)\n. . .\nSep \n11\n \n20\n:51:21  wpantund\n[\n39634\n]\n \nNotice\n: Finished initializing NCP\n\n\n\n\nLeave this terminal window open so that logs from wpantund can be viewed.\n\n\nA user-defined interface is required to communicate with the NCP using \nwpanctl\n. Open a new terminal window and using \nwpanctl\n, connect to the interface you just set up:\n\n\n$ sudo /usr/local/bin/wpanctl -I utun7\nwpanctl:utun7\n\n\n\n\n\nVerify NCP\n\n\nVerify that the NCP is in the correct state:\n\n\nwpanctl:utun7\n status\n\nutun7\n \n=\n \n[\n\n    \nNCP:State\n \n=\n \noffline\n\n    \nDaemon:Enabled\n \n=\n \ntrue\n\n    \nNCP:Version\n \n=\n \nOPENTHREAD/20170716-00745-g79e35c57; NRF52840; Jul 15 2018 09:52:08\n\n    \nDaemon:Version\n \n=\n \n0.08.00d (0.07.01-217-g86d29d6; Jun  9 2018 00:31:51)\n\n    \nConfig:NCP:DriverName\n \n=\n \nspinel\n\n    \nNCP:HardwareAddress\n \n=\n \n[\n38D6B665CE553B4F\n]\n\n\n]\n\n\n\n\n\nNow, you can scan for networks on the NCP Joiner. If you have formed a Thread network, the output should be similar to the below:\n\n\n\n\n\n\nTip\n\n\nYou can follow this guide to \nBuild a Thread network with nRF52840-MDK\n for testing.\n\n\n\n\nUpdate NCP firmware\n\n\nMore features will be added to the NCP firmware gradually over time. The latest pre-built NCP firmware is a \n.hex\n file. You can download here:\n\n\nNCP firmware\n\n\nWhile holding the dongle's RESET/USR button, connect it to your computer. When the Dongle has entered the bootloader mode, the RGB LED pulses RED. It is now ready for programming.\n\n\n\n\nNote\n\n\nFor programming, just follow the \"\nProgramming\n\" section.\n\n\n\n\nHow to build NCP firmware?\n\n\nYou can also build the latest NCP firmware by yourself. The following steps detail how to do that.\n\n\n\n\n\n\nClone and install OpenThread:\n\n\n$ git clone --recursive https://github.com/openthread/openthread.git\n$ \ncd\n openthread\n$ ./bootstrap\n\n\n\n\n\n\n\n\nBuild the firmware with the following commands:\n\n\n$ make -f examples/Makefile-nrf52840 clean\n$ make -f examples/Makefile-nrf52840 \nUSB\n=\n1\n \nBOOTLOADER\n=\n1\n \nBORDER_AGENT\n=\n1\n \nBORDER_ROUTER\n=\n1\n \nCOMMISSIONER\n=\n1\n \nJOINER\n=\n1\n \nUDP_PROXY\n=\n1\n \nCFLAGS\n+=\n-UCONFIG_GPIO_AS_PINRESET\n\n\n\n\n\n\nWarning\n\n\nYou MUST undefine the \nCONFIG_GPIO_AS_PINRESET\n flag, or the Dongle would not enter the bootloader mode next time by holding the dongle's RESET/USR button. \n\n\nPlease remember to add \nCFLAGS+=-UCONFIG_GPIO_AS_PINRESET\n to undefine the \nCONFIG_GPIO_AS_PINRESET\n flag!\n\n\n\n\n\n\n\n\nNavigate to the directory with the OpenThread FTD NCP binary, and convert it to hex format:\n\n\n$ \ncd\n ~/openthread/output/nrf52840/bin\n$ arm-none-eabi-objcopy -O ihex ot-ncp-ftd ot-ncp-ftd.hex\n\n\n\n\nThe \not-ncp-ftd.hex\n file is the expected NCP firmware.\n\n\n\n\n\n\nMore applications\n\n\nSee the following topics for further introduction:\n\n\n\n\nBuild an OpenThread Border Router with Raspberry Pi 3B\n\n\nBuild a Thread Network Sniffer with Wireshark\n\n\n\n\nClone the repository\n\n\nClone the \nmakerdiary/nrf52840-mdk-usb-dongle\n repository or download it as a zip package and put its contents to your working directory.\n\n\n$ git clone https://github.com/makerdiary/nrf52840-mdk-usb-dongle.git\n\n\n\n\nThis repository provides documents and example applications that you can run on your board to ensure that everything is set up correctly.\n\n\nYou can also star or watch this repository to let GitHub send you notifications when something new is added.\n\n\n\n\n\nStar\n\n\n\n\n\n\n\n\nReference\n\n\n\n\n\n\nBuild a Thread network with nRF52840-MDK\n\n\n\n\n\n\nThread Primer\n \u2014 covers all the Thread concepts in this documentation\n\n\n\n\n\n\nBuild a Thread network with nRF52840 boards and OpenThread\n\n\n\n\n\n\nLicense\n\n\nContent on this page is licensed under the \nCreative Commons Attribution 3.0 License\n.\n\n\nCreate an Issue\n\n\nInterested in contributing to this project? Want to report a bug? Feel free to click here:\n\n\n Create an Issue", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started-with-nrf52840-micro-dev-kit-usb-dongle", 
            "text": "Congratulations on getting the nRF52840 Micro Dev Kit USB Dongle!  This guide details how to get started with the nRF52840 Micro Dev Kit USB Dongle development, and what to expect when you do so.  When you get a new dongle, it has been preprogrammed with the OpenThread NCP image. So you can easily set up a Thread NCP Joiner, which can be securely authenticated and commissioned onto a Thread network.", 
            "title": "Getting started with nRF52840 Micro Dev Kit USB Dongle"
        }, 
        {
            "location": "/getting-started/#what-youll-need", 
            "text": "nRF52840 Micro Dev Kit USB Dongle  PC running a Linux based operating system or MacOS  wpantund", 
            "title": "What you'll need"
        }, 
        {
            "location": "/getting-started/#installing-wpantund", 
            "text": "wpantund  is a user-space network interface driver/daemon that provides a native IPv6 network interface to a low-power wireless Network Co-Processor (NCP). It was written and developed by Nest Labs to make supporting Thread connectivity on Unix-like operating systems more straightforward.  wpantund  is designed to marshall all access to the NCP, ensuring that it always remains in a consistent and well-defined state.  Follow the  wpantund Installation Guide  to install wpantund on Ubuntu or macOS.", 
            "title": "Installing wpantund"
        }, 
        {
            "location": "/getting-started/#connecting-the-usb-dongle", 
            "text": "Connect the nRF52840 Micro Dev Kit USB Dongle to your host as shown below:    The USB Dongle will be recognized as an nRF52840 OpenThread Device like this:", 
            "title": "Connecting the USB Dongle"
        }, 
        {
            "location": "/getting-started/#configure-wpantund", 
            "text": "In the NCP design, use  wpantund  to communicate with and manage the Thread device.  In a terminal window, start  wpantund  on the serial port with the NCP, creating the interface  utun7  and enabling info logs:  $ sudo /usr/local/sbin/wpantund -o Config:NCP:SocketPath /dev/cu.usbmodem14112   \\ \n        -o Config:TUN:InterfaceName utun7  \\ \n        -o Daemon:SyslogMask   -info    Tip  To configure wpantund without using command line parameters, modify the  /etc/wpantund.conf  file.   If the NCP is successfully running OpenThread, the output should be similar to the below:  Sep  11   20 :51:21  wpantund [ 39634 ]   Notice : Starting wpantund  0 .08.00d  ( Jun   9   2018   00 :31:51 )  . . .\nSep  11   20 :51:21  wpantund [ 39634 ]   Notice :   SOURCE_VERSION   =   0 .07.01-217-g86d29d6\nSep  11   20 :51:21  wpantund [ 39634 ]   Notice :   BUILD_VERSION   =   0 .07.01-217-g86d29d6\nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : Configuration file  /etc/wpantund.conf  read.\nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : Ready. Using DBUS bus  :1.0 \nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : Running as root without dropping privileges!\nSep  11   20 :51:21  wpantund [ 39634 ]   Notice :  [ -NCP- ] : NCP was reset  ( STATUS_RESET_POWER_ON,  112 ) \nSep  11   20 :51:21  wpantund [ 39634 ]   Error : Unexpected reset during NCP initialization.\nSep  11   20 :51:21  wpantund [ 39634 ]   Error : Resetting and trying again...  ( retry  1 ) \nSep  11   20 :51:21  wpantund [ 39634 ]   Notice :  [ -NCP- ] : NCP was reset  ( STATUS_RESET_POWER_ON,  112 ) \nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : State change:  uninitialized  -   offline \nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : NCP is running  OPENTHREAD/20170716-00745-g79e35c57; NRF52840; Jul 15 2018 09:52:08 \nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : Driver is running  0.08.00d (0.07.01-217-g86d29d6; Jun  9 2018 00:31:51) \nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : Network is not joinable\nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : Resetting interface ( s ) . . .\nSep  11   20 :51:21  wpantund [ 39634 ]   Notice : Finished initializing NCP  Leave this terminal window open so that logs from wpantund can be viewed.  A user-defined interface is required to communicate with the NCP using  wpanctl . Open a new terminal window and using  wpanctl , connect to the interface you just set up:  $ sudo /usr/local/bin/wpanctl -I utun7\nwpanctl:utun7", 
            "title": "Configure wpantund"
        }, 
        {
            "location": "/getting-started/#verify-ncp", 
            "text": "Verify that the NCP is in the correct state:  wpanctl:utun7  status utun7   =   [ \n     NCP:State   =   offline \n     Daemon:Enabled   =   true \n     NCP:Version   =   OPENTHREAD/20170716-00745-g79e35c57; NRF52840; Jul 15 2018 09:52:08 \n     Daemon:Version   =   0.08.00d (0.07.01-217-g86d29d6; Jun  9 2018 00:31:51) \n     Config:NCP:DriverName   =   spinel \n     NCP:HardwareAddress   =   [ 38D6B665CE553B4F ]  ]   Now, you can scan for networks on the NCP Joiner. If you have formed a Thread network, the output should be similar to the below:    Tip  You can follow this guide to  Build a Thread network with nRF52840-MDK  for testing.", 
            "title": "Verify NCP"
        }, 
        {
            "location": "/getting-started/#update-ncp-firmware", 
            "text": "More features will be added to the NCP firmware gradually over time. The latest pre-built NCP firmware is a  .hex  file. You can download here:  NCP firmware  While holding the dongle's RESET/USR button, connect it to your computer. When the Dongle has entered the bootloader mode, the RGB LED pulses RED. It is now ready for programming.   Note  For programming, just follow the \" Programming \" section.", 
            "title": "Update NCP firmware"
        }, 
        {
            "location": "/getting-started/#how-to-build-ncp-firmware", 
            "text": "You can also build the latest NCP firmware by yourself. The following steps detail how to do that.    Clone and install OpenThread:  $ git clone --recursive https://github.com/openthread/openthread.git\n$  cd  openthread\n$ ./bootstrap    Build the firmware with the following commands:  $ make -f examples/Makefile-nrf52840 clean\n$ make -f examples/Makefile-nrf52840  USB = 1   BOOTLOADER = 1   BORDER_AGENT = 1   BORDER_ROUTER = 1   COMMISSIONER = 1   JOINER = 1   UDP_PROXY = 1   CFLAGS += -UCONFIG_GPIO_AS_PINRESET   Warning  You MUST undefine the  CONFIG_GPIO_AS_PINRESET  flag, or the Dongle would not enter the bootloader mode next time by holding the dongle's RESET/USR button.   Please remember to add  CFLAGS+=-UCONFIG_GPIO_AS_PINRESET  to undefine the  CONFIG_GPIO_AS_PINRESET  flag!     Navigate to the directory with the OpenThread FTD NCP binary, and convert it to hex format:  $  cd  ~/openthread/output/nrf52840/bin\n$ arm-none-eabi-objcopy -O ihex ot-ncp-ftd ot-ncp-ftd.hex  The  ot-ncp-ftd.hex  file is the expected NCP firmware.", 
            "title": "How to build NCP firmware?"
        }, 
        {
            "location": "/getting-started/#more-applications", 
            "text": "See the following topics for further introduction:   Build an OpenThread Border Router with Raspberry Pi 3B  Build a Thread Network Sniffer with Wireshark", 
            "title": "More applications"
        }, 
        {
            "location": "/getting-started/#clone-the-repository", 
            "text": "Clone the  makerdiary/nrf52840-mdk-usb-dongle  repository or download it as a zip package and put its contents to your working directory.  $ git clone https://github.com/makerdiary/nrf52840-mdk-usb-dongle.git  This repository provides documents and example applications that you can run on your board to ensure that everything is set up correctly.  You can also star or watch this repository to let GitHub send you notifications when something new is added.   Star", 
            "title": "Clone the repository"
        }, 
        {
            "location": "/getting-started/#reference", 
            "text": "Build a Thread network with nRF52840-MDK    Thread Primer  \u2014 covers all the Thread concepts in this documentation    Build a Thread network with nRF52840 boards and OpenThread", 
            "title": "Reference"
        }, 
        {
            "location": "/getting-started/#license", 
            "text": "Content on this page is licensed under the  Creative Commons Attribution 3.0 License .", 
            "title": "License"
        }, 
        {
            "location": "/getting-started/#create-an-issue", 
            "text": "Interested in contributing to this project? Want to report a bug? Feel free to click here:   Create an Issue", 
            "title": "Create an Issue"
        }, 
        {
            "location": "/programming/", 
            "text": "How to program the nRF52840 Micro Dev Kit USB Dongle\n\n\nThe nRF52840 Micro Dev Kit USB Dongle contains an Open Bootloader with Device Firmware Update (DFU) functionality. You can easily program the Dongle using the following tools:\n\n\n\n\nnRF Connet for Desktop\n\n\nnrfutil\n from the command line.\n\n\n\n\nUsing nRF Connect for Desktop\n\n\nnRF Connect for Desktop contains a programmer app called \nnRF Connect Programmer\n. It is a cross-platform tool that enables programming firmwares to device. Memory layout for Nordic USB devices can be displayed. Content for the HEX files can be displayed, too. Moreover, content of HEX files can be written to the devices.\n\n\nInstallation\n\n\nTo install the application you can download binaries from the \nnRF Connect product page\n on Nordic Semiconductor web pages.\n\n\nnRF Connect currently supports the following operating systems:\n\n\n\n\nWindows\n\n\nUbuntu Linux 64-bit\n\n\nmacOS\n\n\n\n\nAfter nRF Connect is installed, you can find Programmer in the app list by selecting \nAdd/remove apps\n.\n\n\n\n\nProgramming Application\n\n\nTo program the Dongle, it must be in bootloader mode.\n\n\nWhile holding the dongle's RESET/USR button, connect it to your computer. When the Dongle has entered the bootloader mode, the RGB LED pulses RED. The Dongle is now ready for programming.\n\n\nLaunch \nProgrammer\n app from nRF Connect, you can find the dongle and select it to start programming.\n\n\n\n\nAdd an application \n.hex\n file, you will see the memory layout of the HEX file. Make sure the application address starts from \n0x00001000\n, and then Write it into the Dongle:\n\n\nBlinky Hex File\n\n\n\n\nWarning\n\n\nYou MUST provide a correct application firmware without covering the Master Boot Record(MBR) and Bootloader. That is to say the application address should start from \n0x00001000\n and not exceed \n0x000E0000\n.\n\n\n\n\n\n\nAfter programming, please physically reset the Dongle by re-plugging it. The new firmware should work as expected.\n\n\n\n\nProgramming SoftDevice\n\n\nIf you want to run your application with BLE/ANT, a SoftDevice is required before programming the application. \n\n\nSelect a SoftDevice \n.hex\n file from \nnRF5 SDK\n/components/softdevice/s140/hex\n, and then write it into the Dongle:\n\n\n\n\nUsing nrfutil\n\n\nnrfutil\n is a Python package and command-line utility that supports Device Firmware Updates (DFU) and cryptographic functionality.\n\n\nThe nrfutil application and its library offer the following features:\n\n\n\n\nDFU package generation\n\n\nCryptographic key generation, management, and storage\n\n\nBootloader settings generation\n\n\nDFU procedure over any of the following transports:\n\n\nBluetooth Low Energy\n\n\nSerial over UART\n\n\nSerial over USB\n\n\nThread unicast\n\n\nThread multicast\n\n\n\n\n\n\n\n\nHere is the latest user guide from Nordic Semiconductor:\n\n\nnrfutil User Guide v1.3\n\n\nInstalling from PyPI\n\n\nTo install the latest published version from the Python Package Index simply type:\n\n\npip install nrfutil\n\n\n\n\nUpdating Application\n\n\nGenerate a package (.zip file) that you can later use to update. This command takes several options that you can list using:\n\n\nnrfutil pkg generate --help\n\n\n\n\nBelow is an example of the generation of a package from an application's \napp.hex\n file:\n\n\nnrfutil pkg generate --hw-version \n52\n --sd-req 0x00 --application-version \n1\n --application app.hex  app_dfu_package.zip\n\n\n\n\nThere is no SoftDevice required here, just set \n--sd-req\n to \n0x00\n.\n\n\n\n\nTip\n\n\nSee the \nnrfutil User Guide\n for more commands details.\n\n\n\n\nHere we take the \nblinky example\n as an example:\n\n\n\n\nTo update the firmware, the Dongle must be in bootloader mode.\n\n\nWhile holding the dongle's RESET/USR button, connect it to your host. When the Dongle has entered the bootloader mode, the RGB LED pulses RED. It is now ready for programming.\n\n\nThis command takes several options that you can list using:\n\n\nnrfutil dfu usb_serial --help\n\n\n\n\nBelow is the execution of a DFU procedure of the file generated above over \n/dev/cu.usbmodem1411\n:\n\n\nnrfutil dfu usb_serial -pkg dfu_blinky.zip -p /dev/cu.usbmodem1411\n\n\n\n\n\n\nThe new application firmware should work as expected after Device programmed.\n\n\nUpdating SoftDevice\n\n\nIf you want to run your application with BLE/ANT, a SoftDevice is required before programming the application. \n\n\nHere is an example for the generation of a package from a SoftDevice \n.hex\n file:\n\n\nnrfutil pkg generate --hw-version \n52\n --sd-req 0x00 --softdevice s140_nrf52_6.0.0_softdevice.hex --sd-id 0xA9 s140_nrf52_6.0.0_softdevice_dfu_pkg.zip\n\n\n\n\nThen update the package using the following command:\n\n\nnrfutil dfu usb_serial -pkg s140_nrf52_6.0.0_softdevice_dfu_pkg.zip -p /dev/cu.usbmodem1411\n\n\n\n\n\n\nLicense\n\n\nContent on this page is licensed under the \nCreative Commons Attribution 3.0 License\n.\n\n\nCreate an Issue\n\n\nInterested in contributing to this project? Want to report a bug? Feel free to click here:\n\n\n Create an Issue", 
            "title": "Programming"
        }, 
        {
            "location": "/programming/#how-to-program-the-nrf52840-micro-dev-kit-usb-dongle", 
            "text": "The nRF52840 Micro Dev Kit USB Dongle contains an Open Bootloader with Device Firmware Update (DFU) functionality. You can easily program the Dongle using the following tools:   nRF Connet for Desktop  nrfutil  from the command line.", 
            "title": "How to program the nRF52840 Micro Dev Kit USB Dongle"
        }, 
        {
            "location": "/programming/#using-nrf-connect-for-desktop", 
            "text": "nRF Connect for Desktop contains a programmer app called  nRF Connect Programmer . It is a cross-platform tool that enables programming firmwares to device. Memory layout for Nordic USB devices can be displayed. Content for the HEX files can be displayed, too. Moreover, content of HEX files can be written to the devices.", 
            "title": "Using nRF Connect for Desktop"
        }, 
        {
            "location": "/programming/#installation", 
            "text": "To install the application you can download binaries from the  nRF Connect product page  on Nordic Semiconductor web pages.  nRF Connect currently supports the following operating systems:   Windows  Ubuntu Linux 64-bit  macOS   After nRF Connect is installed, you can find Programmer in the app list by selecting  Add/remove apps .", 
            "title": "Installation"
        }, 
        {
            "location": "/programming/#programming-application", 
            "text": "To program the Dongle, it must be in bootloader mode.  While holding the dongle's RESET/USR button, connect it to your computer. When the Dongle has entered the bootloader mode, the RGB LED pulses RED. The Dongle is now ready for programming.  Launch  Programmer  app from nRF Connect, you can find the dongle and select it to start programming.   Add an application  .hex  file, you will see the memory layout of the HEX file. Make sure the application address starts from  0x00001000 , and then Write it into the Dongle:  Blinky Hex File   Warning  You MUST provide a correct application firmware without covering the Master Boot Record(MBR) and Bootloader. That is to say the application address should start from  0x00001000  and not exceed  0x000E0000 .    After programming, please physically reset the Dongle by re-plugging it. The new firmware should work as expected.", 
            "title": "Programming Application"
        }, 
        {
            "location": "/programming/#programming-softdevice", 
            "text": "If you want to run your application with BLE/ANT, a SoftDevice is required before programming the application.   Select a SoftDevice  .hex  file from  nRF5 SDK /components/softdevice/s140/hex , and then write it into the Dongle:", 
            "title": "Programming SoftDevice"
        }, 
        {
            "location": "/programming/#using-nrfutil", 
            "text": "nrfutil  is a Python package and command-line utility that supports Device Firmware Updates (DFU) and cryptographic functionality.  The nrfutil application and its library offer the following features:   DFU package generation  Cryptographic key generation, management, and storage  Bootloader settings generation  DFU procedure over any of the following transports:  Bluetooth Low Energy  Serial over UART  Serial over USB  Thread unicast  Thread multicast     Here is the latest user guide from Nordic Semiconductor:  nrfutil User Guide v1.3", 
            "title": "Using nrfutil"
        }, 
        {
            "location": "/programming/#installing-from-pypi", 
            "text": "To install the latest published version from the Python Package Index simply type:  pip install nrfutil", 
            "title": "Installing from PyPI"
        }, 
        {
            "location": "/programming/#updating-application", 
            "text": "Generate a package (.zip file) that you can later use to update. This command takes several options that you can list using:  nrfutil pkg generate --help  Below is an example of the generation of a package from an application's  app.hex  file:  nrfutil pkg generate --hw-version  52  --sd-req 0x00 --application-version  1  --application app.hex  app_dfu_package.zip  There is no SoftDevice required here, just set  --sd-req  to  0x00 .   Tip  See the  nrfutil User Guide  for more commands details.   Here we take the  blinky example  as an example:   To update the firmware, the Dongle must be in bootloader mode.  While holding the dongle's RESET/USR button, connect it to your host. When the Dongle has entered the bootloader mode, the RGB LED pulses RED. It is now ready for programming.  This command takes several options that you can list using:  nrfutil dfu usb_serial --help  Below is the execution of a DFU procedure of the file generated above over  /dev/cu.usbmodem1411 :  nrfutil dfu usb_serial -pkg dfu_blinky.zip -p /dev/cu.usbmodem1411   The new application firmware should work as expected after Device programmed.", 
            "title": "Updating Application"
        }, 
        {
            "location": "/programming/#updating-softdevice", 
            "text": "If you want to run your application with BLE/ANT, a SoftDevice is required before programming the application.   Here is an example for the generation of a package from a SoftDevice  .hex  file:  nrfutil pkg generate --hw-version  52  --sd-req 0x00 --softdevice s140_nrf52_6.0.0_softdevice.hex --sd-id 0xA9 s140_nrf52_6.0.0_softdevice_dfu_pkg.zip  Then update the package using the following command:  nrfutil dfu usb_serial -pkg s140_nrf52_6.0.0_softdevice_dfu_pkg.zip -p /dev/cu.usbmodem1411", 
            "title": "Updating SoftDevice"
        }, 
        {
            "location": "/programming/#license", 
            "text": "Content on this page is licensed under the  Creative Commons Attribution 3.0 License .", 
            "title": "License"
        }, 
        {
            "location": "/programming/#create-an-issue", 
            "text": "Interested in contributing to this project? Want to report a bug? Feel free to click here:   Create an Issue", 
            "title": "Create an Issue"
        }, 
        {
            "location": "/nrf5-sdk/", 
            "text": "nRF5 SDK \nOffical Software Development Kit for nRF51 and nRF52 Series\n\n\n\n\nIntroduction\n\n\nThe nRF5 SDK provides a rich developing environment for nRF5 Series devices by including a broad selection of drivers, libraries, examples for peripherals, SoftDevices, and proprietary radio protocols.\n\n\nThe SDK is delivered as a plain .zip-archive, which makes it easy to install as well as giving you the freedom to choose the IDE and compiler of your choice.\n\n\nWe provide example applications that you can run on your nRF52840-MDK to ensure that everything is set up correctly. After these tests, you can use the examples as starting point to develop your own applications.\n\n\nBefore we begin, we need to install some software components to build our example applications. \n\n\nSet Up the Development Environment\n\n\nUse the following procedure to create a new development environment:\n\n\n\n\nSetting up the nRF5 SDK Development Environment\n\n\n\n\nCompiling and running blinky example\n\n\nNext, you can try to build one of the examples. Will use the \nblinky\n example here to keep it simple.\n\n\nOpen terminal, change directory and the compile the example:\n\n\n$ \ncd\n ./nrf52840-mdk-usb-dongle/examples/nrf5-sdk/blinky/armgcc/\n$ make\n\n\n\n\nWhile holding the dongle's RESET/USR button, connect it to your computer. When the Dongle has entered the bootloader mode, the RGB LED pulses RED. The Dongle is now ready for programming.\n\n\n\n\nNote\n\n\nFor programming, just follow the \"\nProgramming\n\" section.\n\n\n\n\nAfter programmed correctly, observe that the LEDs are blinking:\n\n\n\n\nRunning examples that use a SoftDevice\n\n\nBefore you can run more advanced examples that use \nBluetooth\n or \nANT\n, you must program the SoftDevice on the board.\n\n\nThe SoftDevice binary is located in folder \ncomponents/softdevice/\nSoftDevice\n/hex\n in the SDK, where \nSoftDevice\n is the name of the SoftDevice. You can also download SoftDevices from \nnordicsemi.com\n.\n\n\n\n\n\n\nOpen a command prompt in the folder that contains the makefile of an example. The example must require a SoftDevice. For example, the \nble_app_blinky\n example.\n\n\n# change to the armgcc directory of \nble_app_blinky\n example\n\n$ \ncd\n ~/nrf52840-mdk-usb-dongle/examples/nrf5-sdk/ble_app_blinky/armgcc\n\n\n\n\n\n\n\n\nCompile the application:\n\n\n$ make clean \n make\n\n\n\n\n\n\n\n\nFollow the \nProgramming\n guide to program the Application and SoftDevice separately\n.\n\n\n\n\n\n\nOpen nRF Connect App and start scanning, a device called \nnRF52840-MDK-Dongle\n will be found! You can try to connect it and turn on/off the LED.\n\n\n\n\n\n\n\n\nMore examples\n\n\nOver time, more example applications will be added to the repository. You can star or watch the \nnrf52840-mdk-usb-dongle\n repository to stay up to date.\n\n\nReference\n\n\n\n\n\n\nNordic nRF5 SDK\n\n\n\n\n\n\nNordic Semiconductor Infocenter\n\n\n\n\n\n\nmakerdiary/nrf52840-mdk-usb-dongle\n\n\n\n\n\n\nLicense\n\n\nContent on this page is licensed under the \nCreative Commons Attribution 3.0 License\n.\n\n\nCreate an Issue\n\n\nInterested in contributing to this project? Want to report a bug? Feel free and click here:\n\n\n Create an Issue", 
            "title": "nRF5 SDK"
        }, 
        {
            "location": "/nrf5-sdk/#nrf5-sdk-offical-software-development-kit-for-nrf51-and-nrf52-series", 
            "text": "", 
            "title": "nRF5 SDK Offical Software Development Kit for nRF51 and nRF52 Series"
        }, 
        {
            "location": "/nrf5-sdk/#introduction", 
            "text": "The nRF5 SDK provides a rich developing environment for nRF5 Series devices by including a broad selection of drivers, libraries, examples for peripherals, SoftDevices, and proprietary radio protocols.  The SDK is delivered as a plain .zip-archive, which makes it easy to install as well as giving you the freedom to choose the IDE and compiler of your choice.  We provide example applications that you can run on your nRF52840-MDK to ensure that everything is set up correctly. After these tests, you can use the examples as starting point to develop your own applications.  Before we begin, we need to install some software components to build our example applications.", 
            "title": "Introduction"
        }, 
        {
            "location": "/nrf5-sdk/#set-up-the-development-environment", 
            "text": "Use the following procedure to create a new development environment:   Setting up the nRF5 SDK Development Environment", 
            "title": "Set Up the Development Environment"
        }, 
        {
            "location": "/nrf5-sdk/#compiling-and-running-blinky-example", 
            "text": "Next, you can try to build one of the examples. Will use the  blinky  example here to keep it simple.  Open terminal, change directory and the compile the example:  $  cd  ./nrf52840-mdk-usb-dongle/examples/nrf5-sdk/blinky/armgcc/\n$ make  While holding the dongle's RESET/USR button, connect it to your computer. When the Dongle has entered the bootloader mode, the RGB LED pulses RED. The Dongle is now ready for programming.   Note  For programming, just follow the \" Programming \" section.   After programmed correctly, observe that the LEDs are blinking:", 
            "title": "Compiling and running blinky example"
        }, 
        {
            "location": "/nrf5-sdk/#running-examples-that-use-a-softdevice", 
            "text": "Before you can run more advanced examples that use  Bluetooth  or  ANT , you must program the SoftDevice on the board.  The SoftDevice binary is located in folder  components/softdevice/ SoftDevice /hex  in the SDK, where  SoftDevice  is the name of the SoftDevice. You can also download SoftDevices from  nordicsemi.com .    Open a command prompt in the folder that contains the makefile of an example. The example must require a SoftDevice. For example, the  ble_app_blinky  example.  # change to the armgcc directory of  ble_app_blinky  example \n$  cd  ~/nrf52840-mdk-usb-dongle/examples/nrf5-sdk/ble_app_blinky/armgcc    Compile the application:  $ make clean   make    Follow the  Programming  guide to program the Application and SoftDevice separately\n.    Open nRF Connect App and start scanning, a device called  nRF52840-MDK-Dongle  will be found! You can try to connect it and turn on/off the LED.", 
            "title": "Running examples that use a SoftDevice"
        }, 
        {
            "location": "/nrf5-sdk/#more-examples", 
            "text": "Over time, more example applications will be added to the repository. You can star or watch the  nrf52840-mdk-usb-dongle  repository to stay up to date.", 
            "title": "More examples"
        }, 
        {
            "location": "/nrf5-sdk/#reference", 
            "text": "Nordic nRF5 SDK    Nordic Semiconductor Infocenter    makerdiary/nrf52840-mdk-usb-dongle", 
            "title": "Reference"
        }, 
        {
            "location": "/nrf5-sdk/#license", 
            "text": "Content on this page is licensed under the  Creative Commons Attribution 3.0 License .", 
            "title": "License"
        }, 
        {
            "location": "/nrf5-sdk/#create-an-issue", 
            "text": "Interested in contributing to this project? Want to report a bug? Feel free and click here:   Create an Issue", 
            "title": "Create an Issue"
        }, 
        {
            "location": "/OTBR/", 
            "text": "OpenThread Border Router \nAn open source border router, designed to work with OpenThread\n\n\nIntroduction\n\n\nA Thread Border Router serves as a gateway between the Internet and the Thread network. OpenThread's implementation of a Border Router is called OpenThread Border Router (OTBR).\n\n\n\n\nOTBR includes a number of features, including:\n\n\n\n\nWeb GUI\n for configuration and management\n\n\nThread Border Agent to support \nexternal commissioning\n\n\nDHCPv6 Prefix Delegation to obtain IPv6 prefixes for a Thread network\n\n\nNAT64\n for connecting to IPv4 networks\n\n\nDNS64\n to allow Thread devices to initiate communications by name to an IPv4-only server\n\n\nThread interface driver using \nwpantund\n\n\n\n\nFor more technical details, \nopenthread.io\n is the best place for you.\n\n\nIn the following documentation sections, you'll build an OpenThread Border Router with nRF52840 Micro Dev Kit USB Dongle and Raspberry Pi 3B.\n\n\nRequired hardware\n\n\n\n\nRaspberry Pi 3B\n\n\nnRF52840 Micro Dev Kit USB Dongle with the latest NCP firmware\n\n\n4 GB (or larger) microSD card and microSD card reader\n\n\nmicroUSB power supply for Raspberry Pi 3B\n\n\n\n\nGetting started\n\n\nComplete the following steps to set up the Border Router on Raspberry Pi 3B.\n\n\nDownload and install Raspbian\n\n\nDownload the \nRASPBIAN STRETCH LITE\n image to your host and follow the \ninstallation guide\n to install the image on an microSD card.\n\n\nSet up the Border Router\n\n\n\n\nWarning\n\n\nBefore you continue, make sure your Raspberry Pi 3B is connected to the internet using Ethernet. The \nbootstrap\n script disables the platform's Wi-Fi interface and the \nsetup\n script requires internet connectivity to download and install \nwpantund\n.\n\n\n\n\nOTBR communicates with the Dongle(serves as NCP) via \nwpantund\n. On Raspberry Pi 3B:\n\n\n\n\n\n\nClone the OTBR repository:\n\n\ngit clone https://github.com/openthread/borderrouter\n\n\n\n\n\n\n\n\nInstall dependencies:\n\n\ncd\n borderrouter\n./script/bootstrap\n\n\n\n\n\n\n\n\nCompile and install OTBR and \nwpantund\n:\n\n\n./script/setup\n\n\n\n\n\n\n\n\nAttach the Dongle to the Border Router platform via USB.\n\n\n\n\n\n\n\n\nConfigure the Dongle's serial port in \nwpantund\n. Add the serial port name to \n/etc/wpantund.conf\n. For example, for a serial port name of \nttyACM0\n:\n\n\nConfig:NCP:SocketPath \n/dev/ttyACM0\n\n\n\n\n\n\n\n\n\nRestart the Border Router. The OTBR service should start on boot.\n\n\n\n\n\n\nVerify services\n\n\nOn Raspberry Pi 3B, verify that all required services are enabled:\n\n\nsudo systemctl status\n\n\n\n\nIf the \nsetup\n script above was successful, the RPI3B is in \nrunning\n state and the following services appear in the output:\n\n\n\n\nwpantund.service\n\n\navahi-daemon.service\n\n\notbr-web.service\n\n\notbr-agent.service\n\n\n\n\nIf the RPI3B is in \ndegraded\n state, some other service has failed to start. Check to see which:\n\n\nsudo systemctl --failed\n\n\n\n\nIf the failed service is \ntayga\n or \ndnsmasq\n, it is normal. These services are completely configured as part of the \nWi-Fi Access Point Setup\n.\n\n\nVerify NCP\n\n\nVerify that the NCP is in the correct state:\n\n\nsudo wpanctl status\n\n\n\n\nwpanctl\n is a command line utility provided with \nwpantund\n. It is used to communicate with the wireless PAN interface (default is \nwpan0\n) that \nwpantund\n is bound to in the NCP design.\n\n\nIf the NCP is successfully running OpenThread and is not a member of a Thread network, the output should be similar to the below:\n\n\nwpan0\n \n=\n \n[\n\n        \nNCP:State\n \n=\n \noffline\n\n        \nDaemon:Enabled\n \n=\n \ntrue\n\n        \nNCP:Version\n \n=\n \nOPENTHREAD/20170716-00889-g4ce55934; NRF52840; Sep 13 2018 20:55:40\n\n        \nDaemon:Version\n \n=\n \n0.08.00d (/4eb20ac; Sep 13 2018 08:00:41)\n\n        \nConfig:NCP:DriverName\n \n=\n \nspinel\n\n        \nNCP:HardwareAddress\n \n=\n \n[\n74358AAD04866C78\n]\n\n\n]\n\n\n\n\n\n\n\nTip\n\n\nFor more features(such as external commissioning), you can follow the \nUpdate NCP firmware\n section to running the latest NCP firmware.\n\n\n\n\nIf the \nNCP:State\n is \nuninitialized\n, troubleshoot with the following:\n\n\n\n\nVerify the RPI3B has sufficient power (use the proper external AC adapter).\n\n\nDisconnect and reconnect the Dongle to the RPI3B.\n\n\n\n\nVerify that the NCP serial device is present. For example, if the device should be attached to \n/dev/ttyACM0\n:\n\n\nls /dev/ttyACM*\n/dev/ttyACM0\n\n\n\n\n\n\n\n\nReset the NCP with \nsudo wpanctl reset\n.\n\n\n\n\nCheck the NCP status again with \nsudo wpanctl status\n.\n\n\n\n\nWeb GUI\n\n\nNow, you can use the OpenThread Border Router (OTBR) Web GUI to configure and form, join, or check the status of a Thread network.\n\n\nThe Border Router enables Access Point mode and advertises the \nBorderRouter-AP\n network default. \n\n\nConnect to the \nBorderRouter-AP\n Wi-Fi network and access the Web GUI by visiting the OTBR's local IPv4 address(\n10.42.0.1\n default) in a mobile browser:\n\n\n\n\nJoin a Thread network\n\n\nUse the \nJoin\n menu option to scan for and join an existing Thread network.\n\n\nForm a Thread network\n\n\nUse the \nForm\n menu option to create a new Thread network.\n\n\n\n\nAfter the network forms, confirm by checking the \nStatus\n menu option or running \nsudo wpanctl status\n on the command line of the OTBR:\n\n\n\n\n\n\nExternal Thread Commissioning\n\n\nOpenThread Border Router (OTBR) features a Thread Border Agent, which supports external Thread Commissioning. In external Thread Commissioning, a device outside of the Thread network (for example, a mobile phone) commissions new devices onto the network.\n\n\n\n\nThis section details how to use the Thread Commissioning App to commission an OpenThread device onto a network created and managed by the OTBR Web GUI.\n\n\nSet up the Joiner device\n\n\nYou should prepare another Dongle or an nRF52840 board(such as \nnRF52840-MDK\n). Flash the board with the OpenThread CLI firmware. Here is the pre-built CLI firmware for the Dongle:\n\n\nCLI firmware\n\n\n\n\nNote\n\n\nFor programming, just follow the \"\nProgramming\n\" section.\n\n\n\n\nOnce the Joiner device is ready, obtain its factory-assigned IEEE EUI-64. Use the \neui64\n command in the OpenThread CLI:\n\n\n eui64\n4499f69d088dac4b\nDone\n\n\n\n\nDownload the Thread Commissioning App\n\n\nExternal commissioning is supported by the Thread Commissioning App, available for download on the Google Play Store for Android devices.\n\n\nThread Commissioning App\n\n\nConnect to the Border Router\n\n\nStart the Thread Commissioning App, then tap \nFIND WI-FI NETWORK\n and connect your phone running the Thread Commissioning App to the Wi-Fi access point.\n\n\n\n\n\n\nSelect the target Border Router from the available list. The name is the same as the Thread network created by the OTBR Web GUI. If the same Border Router shows up multiple times with different IPv4 and IPv6 addresses, select the one with the static IPv4 address used for the Wi-Fi access point setup (\n10.42.0.1\n here).\n\n\nWhen prompted for a password, enter the passphrase (Commissioner Credential) set by the OTBR Web GUI.\n\n\n\n\nCommission the Joiner\n\n\nOnce connected to the Border Router, the app provides the option to scan a Connect QR Code or enter a Join Passphrase manually.\n\n\nThread Connect QR Codes are created with the following text string format:\n\n\nv\n=\n1\neui\n=\n4499f69d088dac4b\ncc\n=\nJ01NU5\n\n\nWhere \neui\n is the Joiner device's EUI64 value and \ncc\n is the Joiner Credential.\n\n\nUse this text string with an online QR Code generator(such as \nunitag.io\n) to create a QR Code for scanning.\n\n\n\n\nIn the Thread Commissioning App, scan the Connect QR Code of the Joiner device:\n\n\n\n\nWhile the app is waiting, enter the OpenThread CLI on the Joiner device and start the Joiner role with that same Joiner Credential:\n\n\n ifconfig up\nDone\n\n joiner start J01NU5\nDone\n\n\n\n\nWait a minute for the DTLS handshake to complete between the Commissioner and Joiner:\n\n\n Join success\n\n\n\n\n\n\nJoin the network\n\n\nOn the Joiner device, start the Thread protocol to automatically join the network.\n\n\n thread start\nDone\n\n\n\n\nCheck the state after a few moments to confirm. It may initially start as a Child, but within two minutes, it will upgrade to a Router.\n\n\n state\nrouter\nDone\n\n\n\n\nObtain the addresses of the joiner by typing \nipaddr\n:\n\n\n ipaddr\nfd11:1111:1122:0:0:ff:fe00:4400\nfd11:22:0:0:8250:8753:2ff9:ac2f\nfe80:0:0:0:c43d:cdd:9e66:6d4e\nfd11:1111:1122:0:87a9:87be:ed3a:299e\nDone\n\n\n\n\nCheck the Internet connectivity\n\n\nTest the connectivity between the Joiner device in the Thread network and the Internet by pinging a public IPv4 address. To reach the IPv4 address from the Thread device, a Well-Known Prefix of \n64:ff9b::/96\n and an IPv4 address of the destination are used. \n\n\nTo ping Google\u2019s DNS \n8.8.8.8\n from the IPv6 address, append a hexadecimal form of the IPv6 to the Well-Known Prefix resulting in: \n64:ff9b::808:808\n.\n\n\n ping \n64\n:ff9b::808:808\n\n \n16\n bytes from \n64\n:ff9b:0:0:0:0:808:808: \nicmp_seq\n=\n0\n \nhlim\n=\n39\n \ntime\n=\n37ms\n\n\n ping \n64\n:ff9b::808:808\n\n \n16\n bytes from \n64\n:ff9b:0:0:0:0:808:808: \nicmp_seq\n=\n1\n \nhlim\n=\n39\n \ntime\n=\n35ms\n\n\n ping \n64\n:ff9b::808:808\n\n \n16\n bytes from \n64\n:ff9b:0:0:0:0:808:808: \nicmp_seq\n=\n2\n \nhlim\n=\n39\n \ntime\n=\n35ms\n\n\n\n\nCongratulations!\n\n\nYou've successfully created an OpenThread Border Router, while allowing the Joiner device in the Thread network communicating with the Internet.\n\n\nReference\n\n\n\n\nopenthread.io/guides/border-router\n\n\nNordic Thread Border Router\n\n\nBuild a Thread network with nRF52840-MDK\n\n\n\n\nLicense\n\n\nContent on this page is licensed under the \nCreative Commons Attribution 3.0 License\n.\n\n\nCreate an Issue\n\n\nInterested in contributing to this project? Want to report a bug? Feel free to click here:\n\n\n Create an Issue", 
            "title": "OpenThread Border Router"
        }, 
        {
            "location": "/OTBR/#openthread-border-router-an-open-source-border-router-designed-to-work-with-openthread", 
            "text": "", 
            "title": "OpenThread Border Router An open source border router, designed to work with OpenThread"
        }, 
        {
            "location": "/OTBR/#introduction", 
            "text": "A Thread Border Router serves as a gateway between the Internet and the Thread network. OpenThread's implementation of a Border Router is called OpenThread Border Router (OTBR).   OTBR includes a number of features, including:   Web GUI  for configuration and management  Thread Border Agent to support  external commissioning  DHCPv6 Prefix Delegation to obtain IPv6 prefixes for a Thread network  NAT64  for connecting to IPv4 networks  DNS64  to allow Thread devices to initiate communications by name to an IPv4-only server  Thread interface driver using  wpantund   For more technical details,  openthread.io  is the best place for you.  In the following documentation sections, you'll build an OpenThread Border Router with nRF52840 Micro Dev Kit USB Dongle and Raspberry Pi 3B.", 
            "title": "Introduction"
        }, 
        {
            "location": "/OTBR/#required-hardware", 
            "text": "Raspberry Pi 3B  nRF52840 Micro Dev Kit USB Dongle with the latest NCP firmware  4 GB (or larger) microSD card and microSD card reader  microUSB power supply for Raspberry Pi 3B", 
            "title": "Required hardware"
        }, 
        {
            "location": "/OTBR/#getting-started", 
            "text": "Complete the following steps to set up the Border Router on Raspberry Pi 3B.", 
            "title": "Getting started"
        }, 
        {
            "location": "/OTBR/#download-and-install-raspbian", 
            "text": "Download the  RASPBIAN STRETCH LITE  image to your host and follow the  installation guide  to install the image on an microSD card.", 
            "title": "Download and install Raspbian"
        }, 
        {
            "location": "/OTBR/#set-up-the-border-router", 
            "text": "Warning  Before you continue, make sure your Raspberry Pi 3B is connected to the internet using Ethernet. The  bootstrap  script disables the platform's Wi-Fi interface and the  setup  script requires internet connectivity to download and install  wpantund .   OTBR communicates with the Dongle(serves as NCP) via  wpantund . On Raspberry Pi 3B:    Clone the OTBR repository:  git clone https://github.com/openthread/borderrouter    Install dependencies:  cd  borderrouter\n./script/bootstrap    Compile and install OTBR and  wpantund :  ./script/setup    Attach the Dongle to the Border Router platform via USB.     Configure the Dongle's serial port in  wpantund . Add the serial port name to  /etc/wpantund.conf . For example, for a serial port name of  ttyACM0 :  Config:NCP:SocketPath  /dev/ttyACM0     Restart the Border Router. The OTBR service should start on boot.", 
            "title": "Set up the Border Router"
        }, 
        {
            "location": "/OTBR/#verify-services", 
            "text": "On Raspberry Pi 3B, verify that all required services are enabled:  sudo systemctl status  If the  setup  script above was successful, the RPI3B is in  running  state and the following services appear in the output:   wpantund.service  avahi-daemon.service  otbr-web.service  otbr-agent.service   If the RPI3B is in  degraded  state, some other service has failed to start. Check to see which:  sudo systemctl --failed  If the failed service is  tayga  or  dnsmasq , it is normal. These services are completely configured as part of the  Wi-Fi Access Point Setup .", 
            "title": "Verify services"
        }, 
        {
            "location": "/OTBR/#verify-ncp", 
            "text": "Verify that the NCP is in the correct state:  sudo wpanctl status  wpanctl  is a command line utility provided with  wpantund . It is used to communicate with the wireless PAN interface (default is  wpan0 ) that  wpantund  is bound to in the NCP design.  If the NCP is successfully running OpenThread and is not a member of a Thread network, the output should be similar to the below:  wpan0   =   [ \n         NCP:State   =   offline \n         Daemon:Enabled   =   true \n         NCP:Version   =   OPENTHREAD/20170716-00889-g4ce55934; NRF52840; Sep 13 2018 20:55:40 \n         Daemon:Version   =   0.08.00d (/4eb20ac; Sep 13 2018 08:00:41) \n         Config:NCP:DriverName   =   spinel \n         NCP:HardwareAddress   =   [ 74358AAD04866C78 ]  ]    Tip  For more features(such as external commissioning), you can follow the  Update NCP firmware  section to running the latest NCP firmware.   If the  NCP:State  is  uninitialized , troubleshoot with the following:   Verify the RPI3B has sufficient power (use the proper external AC adapter).  Disconnect and reconnect the Dongle to the RPI3B.   Verify that the NCP serial device is present. For example, if the device should be attached to  /dev/ttyACM0 :  ls /dev/ttyACM*\n/dev/ttyACM0    Reset the NCP with  sudo wpanctl reset .   Check the NCP status again with  sudo wpanctl status .", 
            "title": "Verify NCP"
        }, 
        {
            "location": "/OTBR/#web-gui", 
            "text": "Now, you can use the OpenThread Border Router (OTBR) Web GUI to configure and form, join, or check the status of a Thread network.  The Border Router enables Access Point mode and advertises the  BorderRouter-AP  network default.   Connect to the  BorderRouter-AP  Wi-Fi network and access the Web GUI by visiting the OTBR's local IPv4 address( 10.42.0.1  default) in a mobile browser:", 
            "title": "Web GUI"
        }, 
        {
            "location": "/OTBR/#join-a-thread-network", 
            "text": "Use the  Join  menu option to scan for and join an existing Thread network.", 
            "title": "Join a Thread network"
        }, 
        {
            "location": "/OTBR/#form-a-thread-network", 
            "text": "Use the  Form  menu option to create a new Thread network.   After the network forms, confirm by checking the  Status  menu option or running  sudo wpanctl status  on the command line of the OTBR:", 
            "title": "Form a Thread network"
        }, 
        {
            "location": "/OTBR/#external-thread-commissioning", 
            "text": "OpenThread Border Router (OTBR) features a Thread Border Agent, which supports external Thread Commissioning. In external Thread Commissioning, a device outside of the Thread network (for example, a mobile phone) commissions new devices onto the network.   This section details how to use the Thread Commissioning App to commission an OpenThread device onto a network created and managed by the OTBR Web GUI.", 
            "title": "External Thread Commissioning"
        }, 
        {
            "location": "/OTBR/#set-up-the-joiner-device", 
            "text": "You should prepare another Dongle or an nRF52840 board(such as  nRF52840-MDK ). Flash the board with the OpenThread CLI firmware. Here is the pre-built CLI firmware for the Dongle:  CLI firmware   Note  For programming, just follow the \" Programming \" section.   Once the Joiner device is ready, obtain its factory-assigned IEEE EUI-64. Use the  eui64  command in the OpenThread CLI:   eui64\n4499f69d088dac4b\nDone", 
            "title": "Set up the Joiner device"
        }, 
        {
            "location": "/OTBR/#download-the-thread-commissioning-app", 
            "text": "External commissioning is supported by the Thread Commissioning App, available for download on the Google Play Store for Android devices.  Thread Commissioning App", 
            "title": "Download the Thread Commissioning App"
        }, 
        {
            "location": "/OTBR/#connect-to-the-border-router", 
            "text": "Start the Thread Commissioning App, then tap  FIND WI-FI NETWORK  and connect your phone running the Thread Commissioning App to the Wi-Fi access point.    Select the target Border Router from the available list. The name is the same as the Thread network created by the OTBR Web GUI. If the same Border Router shows up multiple times with different IPv4 and IPv6 addresses, select the one with the static IPv4 address used for the Wi-Fi access point setup ( 10.42.0.1  here).  When prompted for a password, enter the passphrase (Commissioner Credential) set by the OTBR Web GUI.", 
            "title": "Connect to the Border Router"
        }, 
        {
            "location": "/OTBR/#commission-the-joiner", 
            "text": "Once connected to the Border Router, the app provides the option to scan a Connect QR Code or enter a Join Passphrase manually.  Thread Connect QR Codes are created with the following text string format:  v = 1 eui = 4499f69d088dac4b cc = J01NU5 \nWhere  eui  is the Joiner device's EUI64 value and  cc  is the Joiner Credential.  Use this text string with an online QR Code generator(such as  unitag.io ) to create a QR Code for scanning.   In the Thread Commissioning App, scan the Connect QR Code of the Joiner device:   While the app is waiting, enter the OpenThread CLI on the Joiner device and start the Joiner role with that same Joiner Credential:   ifconfig up\nDone  joiner start J01NU5\nDone  Wait a minute for the DTLS handshake to complete between the Commissioner and Joiner:   Join success", 
            "title": "Commission the Joiner"
        }, 
        {
            "location": "/OTBR/#join-the-network", 
            "text": "On the Joiner device, start the Thread protocol to automatically join the network.   thread start\nDone  Check the state after a few moments to confirm. It may initially start as a Child, but within two minutes, it will upgrade to a Router.   state\nrouter\nDone  Obtain the addresses of the joiner by typing  ipaddr :   ipaddr\nfd11:1111:1122:0:0:ff:fe00:4400\nfd11:22:0:0:8250:8753:2ff9:ac2f\nfe80:0:0:0:c43d:cdd:9e66:6d4e\nfd11:1111:1122:0:87a9:87be:ed3a:299e\nDone", 
            "title": "Join the network"
        }, 
        {
            "location": "/OTBR/#check-the-internet-connectivity", 
            "text": "Test the connectivity between the Joiner device in the Thread network and the Internet by pinging a public IPv4 address. To reach the IPv4 address from the Thread device, a Well-Known Prefix of  64:ff9b::/96  and an IPv4 address of the destination are used.   To ping Google\u2019s DNS  8.8.8.8  from the IPv6 address, append a hexadecimal form of the IPv6 to the Well-Known Prefix resulting in:  64:ff9b::808:808 .   ping  64 :ff9b::808:808   16  bytes from  64 :ff9b:0:0:0:0:808:808:  icmp_seq = 0   hlim = 39   time = 37ms  ping  64 :ff9b::808:808   16  bytes from  64 :ff9b:0:0:0:0:808:808:  icmp_seq = 1   hlim = 39   time = 35ms  ping  64 :ff9b::808:808   16  bytes from  64 :ff9b:0:0:0:0:808:808:  icmp_seq = 2   hlim = 39   time = 35ms", 
            "title": "Check the Internet connectivity"
        }, 
        {
            "location": "/OTBR/#congratulations", 
            "text": "You've successfully created an OpenThread Border Router, while allowing the Joiner device in the Thread network communicating with the Internet.", 
            "title": "Congratulations!"
        }, 
        {
            "location": "/OTBR/#reference", 
            "text": "openthread.io/guides/border-router  Nordic Thread Border Router  Build a Thread network with nRF52840-MDK", 
            "title": "Reference"
        }, 
        {
            "location": "/OTBR/#license", 
            "text": "Content on this page is licensed under the  Creative Commons Attribution 3.0 License .", 
            "title": "License"
        }, 
        {
            "location": "/OTBR/#create-an-issue", 
            "text": "Interested in contributing to this project? Want to report a bug? Feel free to click here:   Create an Issue", 
            "title": "Create an Issue"
        }, 
        {
            "location": "/thread-sniffer/", 
            "text": "Build a Thread Network Sniffer with Wireshark\n\n\nThis guide details how to set up a Thread Sniffer, which can help you to efficiently analyze Thread network traffic.\n\n\nDuring development, you may need to check what kind of data is wirelessly transmitted over the Thread network. With the help of the following instructions, you can set up a sniffer which allows to dynamically monitor the IEEE 802.15.4 wireless traffic. The captured frames are passed to Wireshark which allows to decode the Thread protocol and other protocols that it uses like 6LoWPAN, IPv6, UDP, CoAP, providing complete information about the messages that are sent in the mesh network.\n\n\nWhat you'll need\n\n\n\n\nnRF52840 Micro Dev Kit USB Dongle\n\n\nPC running a Linux based operating system or MacOS\n\n\nWireshark 2.4.1 or newer\n\n\nPython 2.7.10\n\n\n\n\nInstalling Wireshark\n\n\n\n\nAbout Wireshark\n\n\nWireshark\n is the world\u2019s foremost and widely-used network protocol analyzer. It lets you see what\u2019s happening on your network at a microscopic level and is the de facto (and often de jure) standard across many commercial and non-profit enterprises, government agencies, and educational institutions.\n\n\n\n\nOn MacOS, go to the \nWireshark Download page\n and download the current stable release of Wireshark.\n\n\nOn Ubuntu Linux, you can run the following commands:\n\n\n$ sudo add-apt-repository ppa:dreibh/ppa\n$ sudo apt-get update\n$ sudo apt-get install wireshark\n\n\n\n\nConnecting the USB Dongle\n\n\nConnect the nRF52840 Micro Dev Kit USB Dongle to your host as shown below: \n\n\n\n\nThe USB Dongle will be recognized as an nRF52840 OpenThread Device like this:\n\n\n\n\nStarting Wireshark with the Sniffer\n\n\nAt first, you must clone the \npyspinel repository\n which will be used as an interface between NCP and Wireshark.\n\n\n$ git clone https://github.com/openthread/pyspinel.git\n$ \ncd\n pyspinel\n$ sudo pip install --user pyserial\n$ sudo pip install --user ipaddress\n\n\n\n\nThen start Wireshark with the following command:\n\n\n$ sudo python ./sniffer.py -c \n11\n -n \n1\n -b \n115200\n --crc -u /dev/cu.usbmodem1411 --no-reset \n|\n wireshark -k -i -\n\n\n\n\nThe parameters stand for the following: \n\n\n\n\n-c\n: Thread Channel\n\n\n-n\n: Node ID \n\n\n\u2013crc\n: Disables the wrong FCS warning resulting from the fact that Nordic radio replaces one byte of CRC with LQI after a packet is received and verified. \n\n\n\u2013no-reset\n: Used when NCP is connected via the native USB connection, otherwise this parameter should be omitted.\n\n\n\n\n\n\nEnter the menu \nWireshark\n -\n \nPreferences\n, and then go to \nProtocols\n -\n \nIEEE 802.15.4\n.\n\n\n\n\nEdit the Decryption Keys with the following values:\n\n\n\n\n\n\nDecryption key: \n00112233445566778899aabbccddeeff\n\n\n\n\n\n\nDecryption key index: \n1\n\n\n\n\n\n\nKey hash: \nThread hash\n\n\n\n\n\n\n\n\nGo to \nProtocols\n -\n \nThread\n and edit the settings.\n\n\n\n\nGo to \nProtocols\n -\n \n6LoWPAN\n and edit the settings.\n\n\n\n\nNow you are ready to get the Thread packets and analyze network traffic.\n\n\n\n\nTip\n\n\nYou can follow this guide to \nBuild a Thread network with nRF52840-MDK\n for testing.\n\n\n\n\n\n\nReference\n\n\n\n\nThread Sniffer based on nRF52840 with Wireshark\n\n\npyspinel repository\n\n\nWireshark Developer\u2019s Guide\n\n\n\n\nLicense\n\n\nContent on this page is licensed under the \nCreative Commons Attribution 3.0 License\n.\n\n\nCreate an Issue\n\n\nInterested in contributing to this project? Want to report a bug? Feel free to click here:\n\n\n Create an Issue", 
            "title": "Thread Network Sniffer"
        }, 
        {
            "location": "/thread-sniffer/#build-a-thread-network-sniffer-with-wireshark", 
            "text": "This guide details how to set up a Thread Sniffer, which can help you to efficiently analyze Thread network traffic.  During development, you may need to check what kind of data is wirelessly transmitted over the Thread network. With the help of the following instructions, you can set up a sniffer which allows to dynamically monitor the IEEE 802.15.4 wireless traffic. The captured frames are passed to Wireshark which allows to decode the Thread protocol and other protocols that it uses like 6LoWPAN, IPv6, UDP, CoAP, providing complete information about the messages that are sent in the mesh network.", 
            "title": "Build a Thread Network Sniffer with Wireshark"
        }, 
        {
            "location": "/thread-sniffer/#what-youll-need", 
            "text": "nRF52840 Micro Dev Kit USB Dongle  PC running a Linux based operating system or MacOS  Wireshark 2.4.1 or newer  Python 2.7.10", 
            "title": "What you'll need"
        }, 
        {
            "location": "/thread-sniffer/#installing-wireshark", 
            "text": "About Wireshark  Wireshark  is the world\u2019s foremost and widely-used network protocol analyzer. It lets you see what\u2019s happening on your network at a microscopic level and is the de facto (and often de jure) standard across many commercial and non-profit enterprises, government agencies, and educational institutions.   On MacOS, go to the  Wireshark Download page  and download the current stable release of Wireshark.  On Ubuntu Linux, you can run the following commands:  $ sudo add-apt-repository ppa:dreibh/ppa\n$ sudo apt-get update\n$ sudo apt-get install wireshark", 
            "title": "Installing Wireshark"
        }, 
        {
            "location": "/thread-sniffer/#connecting-the-usb-dongle", 
            "text": "Connect the nRF52840 Micro Dev Kit USB Dongle to your host as shown below:    The USB Dongle will be recognized as an nRF52840 OpenThread Device like this:", 
            "title": "Connecting the USB Dongle"
        }, 
        {
            "location": "/thread-sniffer/#starting-wireshark-with-the-sniffer", 
            "text": "At first, you must clone the  pyspinel repository  which will be used as an interface between NCP and Wireshark.  $ git clone https://github.com/openthread/pyspinel.git\n$  cd  pyspinel\n$ sudo pip install --user pyserial\n$ sudo pip install --user ipaddress  Then start Wireshark with the following command:  $ sudo python ./sniffer.py -c  11  -n  1  -b  115200  --crc -u /dev/cu.usbmodem1411 --no-reset  |  wireshark -k -i -  The parameters stand for the following:    -c : Thread Channel  -n : Node ID   \u2013crc : Disables the wrong FCS warning resulting from the fact that Nordic radio replaces one byte of CRC with LQI after a packet is received and verified.   \u2013no-reset : Used when NCP is connected via the native USB connection, otherwise this parameter should be omitted.    Enter the menu  Wireshark  -   Preferences , and then go to  Protocols  -   IEEE 802.15.4 .   Edit the Decryption Keys with the following values:    Decryption key:  00112233445566778899aabbccddeeff    Decryption key index:  1    Key hash:  Thread hash     Go to  Protocols  -   Thread  and edit the settings.   Go to  Protocols  -   6LoWPAN  and edit the settings.   Now you are ready to get the Thread packets and analyze network traffic.   Tip  You can follow this guide to  Build a Thread network with nRF52840-MDK  for testing.", 
            "title": "Starting Wireshark with the Sniffer"
        }, 
        {
            "location": "/thread-sniffer/#reference", 
            "text": "Thread Sniffer based on nRF52840 with Wireshark  pyspinel repository  Wireshark Developer\u2019s Guide", 
            "title": "Reference"
        }, 
        {
            "location": "/thread-sniffer/#license", 
            "text": "Content on this page is licensed under the  Creative Commons Attribution 3.0 License .", 
            "title": "License"
        }, 
        {
            "location": "/thread-sniffer/#create-an-issue", 
            "text": "Interested in contributing to this project? Want to report a bug? Feel free to click here:   Create an Issue", 
            "title": "Create an Issue"
        }, 
        {
            "location": "/how-to-buy/", 
            "text": "How to Buy nRF52840 Micro Dev Kit USB Dongle\n\n\nBuy Online\n\n\nnRF52840 Micro Dev Kit USB Dongle is available on the following channels (click to go directly to the product):\n\n\n\n\n\n\n\n\n\n\nBulk \n Customization\n\n\nWe are ready to customize our electronics and firmware to better meet your solution's needs. Many of our platforms are prepared for customization.\n\n\nIf you would like to do some serious business, \ndrop a line\n and we'll reply before you know it.\n\n\n Email Us", 
            "title": "How to Buy"
        }, 
        {
            "location": "/how-to-buy/#how-to-buy-nrf52840-micro-dev-kit-usb-dongle", 
            "text": "", 
            "title": "How to Buy nRF52840 Micro Dev Kit USB Dongle"
        }, 
        {
            "location": "/how-to-buy/#buy-online", 
            "text": "nRF52840 Micro Dev Kit USB Dongle is available on the following channels (click to go directly to the product):", 
            "title": "Buy Online"
        }, 
        {
            "location": "/how-to-buy/#bulk-customization", 
            "text": "We are ready to customize our electronics and firmware to better meet your solution's needs. Many of our platforms are prepared for customization.  If you would like to do some serious business,  drop a line  and we'll reply before you know it.   Email Us", 
            "title": "Bulk &amp; Customization"
        }, 
        {
            "location": "/CONTRIBUTING/", 
            "text": "Interested in contributing to the nRF52840 Micro Dev Kit USB Dongle project? Want to report a bug? Before you do, please read the following guidelines.\n\n\nGot a question or problem?\n\n\nFor quick questions there's no need to open an issue as you can comment at the bottom of the corresponding page.\n\n\nFound a bug?\n\n\nIf you found a bug in the source code, you can help us by submitting an issue to the \nissue tracker\n in our GitHub repository. Even better, you can submit a Pull Request with a fix.\n\n\nMissing a feature?\n\n\nYou can request a new feature by submitting an issue to our GitHub Repository. Be sure that it is of use for everyone.\n\n\n Create an Issue", 
            "title": "Contributing"
        }, 
        {
            "location": "/CONTRIBUTING/#got-a-question-or-problem", 
            "text": "For quick questions there's no need to open an issue as you can comment at the bottom of the corresponding page.", 
            "title": "Got a question or problem?"
        }, 
        {
            "location": "/CONTRIBUTING/#found-a-bug", 
            "text": "If you found a bug in the source code, you can help us by submitting an issue to the  issue tracker  in our GitHub repository. Even better, you can submit a Pull Request with a fix.", 
            "title": "Found a bug?"
        }, 
        {
            "location": "/CONTRIBUTING/#missing-a-feature", 
            "text": "You can request a new feature by submitting an issue to our GitHub Repository. Be sure that it is of use for everyone.   Create an Issue", 
            "title": "Missing a feature?"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "MIT License\n\n\nCopyright \n 2019 \nmakerdiary.com\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}